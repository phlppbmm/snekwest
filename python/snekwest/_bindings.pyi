# pylint: skip-file
"""Type stubs for the snekwest._bindings native extension module."""

from datetime import timedelta
from typing import Any, Iterator, Optional, Tuple, Union

from .cookies import RequestsCookieJar
from .structures import CaseInsensitiveDict

class PreparedRequest:
    method: Optional[str]
    url: Optional[str]
    headers: CaseInsensitiveDict
    body: Optional[Union[bytes, str]]
    hooks: dict[str, list]

    def __init__(self) -> None: ...
    def prepare(
        self,
        *,
        method: Optional[str] = None,
        url: Optional[str] = None,
        headers: Optional[Any] = None,
        files: Optional[Any] = None,
        data: Optional[Any] = None,
        params: Optional[Any] = None,
        auth: Optional[Any] = None,
        cookies: Optional[Any] = None,
        hooks: Optional[Any] = None,
        json: Optional[Any] = None,
    ) -> None: ...
    def prepare_method(self, method: Optional[str]) -> None: ...
    def prepare_url(self, url: str, params: Optional[Any] = None) -> None: ...
    def prepare_headers(self, headers: Optional[Any]) -> None: ...
    def prepare_body(
        self, data: Any = None, files: Any = None, json: Any = None
    ) -> None: ...
    def prepare_content_length(self, body: Optional[Any]) -> None: ...
    def prepare_auth(self, auth: Optional[Any], url: str = "") -> None: ...
    def prepare_cookies(self, cookies: Optional[Any]) -> None: ...
    def prepare_hooks(self, hooks: Optional[Any]) -> None: ...
    def copy(self) -> "PreparedRequest": ...
    @property
    def path_url(self) -> str: ...
    @property
    def _cookies(self) -> RequestsCookieJar: ...
    @property
    def _body_position(self) -> Optional[int]: ...
    def __repr__(self) -> str: ...

class Response:
    """HTTP response from the Rust backend."""

    status_code: int
    url: str
    headers: CaseInsensitiveDict
    cookies: RequestsCookieJar
    reason: Optional[str]
    elapsed: timedelta
    history: list["Response"]
    encoding: Optional[str]
    request: Optional[PreparedRequest]
    raw: Any
    _next: Optional[PreparedRequest]
    _content: Union[bytes, bool]
    _content_consumed: bool

    @property
    def ok(self) -> bool: ...
    @property
    def is_redirect(self) -> bool: ...
    @property
    def is_permanent_redirect(self) -> bool: ...
    @property
    def apparent_encoding(self) -> str: ...
    @property
    def content(self) -> bytes: ...
    @property
    def text(self) -> str: ...
    @property
    def links(self) -> dict[str, dict[str, str]]: ...
    def json(self, **kwargs: Any) -> Any: ...
    def raise_for_status(self) -> None: ...
    def iter_content(
        self, chunk_size: Optional[int] = 1, decode_unicode: bool = False
    ) -> Iterator[bytes]: ...
    def iter_lines(
        self,
        chunk_size: int = 512,
        decode_unicode: bool = False,
        delimiter: Optional[str] = None,
    ) -> Iterator[bytes]: ...
    def close(self) -> None: ...
    def __enter__(self) -> "Response": ...
    def __exit__(self, *args: Any) -> None: ...
    def __bool__(self) -> bool: ...
    def __iter__(self) -> Iterator[bytes]: ...
    def __repr__(self) -> str: ...

class StreamingBody:
    def read(self, size: int = 8192) -> bytes: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...

class ContentIterator:
    def __iter__(self) -> "ContentIterator": ...
    def __next__(self) -> bytes: ...

class LinesIterator:
    def __iter__(self) -> "LinesIterator": ...
    def __next__(self) -> bytes: ...

class Session:
    """HTTP session backed by a Rust reqwest client.

    Designed to be subclassed with SessionRedirectMixin for full functionality.
    """

    headers: Any  # CaseInsensitiveDict
    cookies: Any  # RequestsCookieJar
    auth: Any
    proxies: Any  # dict
    hooks: Any  # dict
    params: Any  # dict
    stream: bool
    verify: Any  # bool or str
    cert: Any  # str or tuple or None
    max_redirects: int
    trust_env: bool
    adapters: Any  # OrderedDict

    def __init__(self) -> None: ...
    def __enter__(self) -> "Session": ...
    def __exit__(self, *args: Any) -> None: ...
    def request(
        self,
        method: Union[str, bytes],
        url: str,
        *,
        params: Optional[Any] = None,
        data: Optional[Any] = None,
        headers: Optional[Any] = None,
        cookies: Optional[Any] = None,
        files: Optional[Any] = None,
        auth: Optional[Any] = None,
        timeout: Optional[Any] = None,
        allow_redirects: bool = True,
        proxies: Optional[Any] = None,
        hooks: Optional[Any] = None,
        stream: Optional[Any] = None,
        verify: Optional[Any] = None,
        cert: Optional[Any] = None,
        json: Optional[Any] = None,
    ) -> Response: ...
    def get(self, url: str, **kwargs: Any) -> Response: ...
    def options(self, url: str, **kwargs: Any) -> Response: ...
    def head(self, url: str, **kwargs: Any) -> Response: ...
    def post(
        self, url: str, data: Any = None, json: Any = None, **kwargs: Any
    ) -> Response: ...
    def put(self, url: str, data: Any = None, **kwargs: Any) -> Response: ...
    def patch(self, url: str, data: Any = None, **kwargs: Any) -> Response: ...
    def delete(self, url: str, **kwargs: Any) -> Response: ...
    def send(self, request: PreparedRequest, **kwargs: Any) -> Response: ...
    def prepare_request(self, request: Any) -> PreparedRequest: ...
    def merge_environment_settings(
        self, url: Any, proxies: Any, stream: Any, verify: Any, cert: Any
    ) -> dict[str, Any]: ...
    def get_adapter(self, url: str) -> Any: ...
    def mount(self, prefix: str, adapter: Any) -> None: ...
    def close(self) -> None: ...

    # Internal transport method (used by HTTPAdapter)
    def make_request(
        self,
        method: str,
        url: str,
        *,
        params: Optional[dict[str, str]] = None,
        data: Optional[Union[dict[str, str], str, bytes]] = None,
        json: Optional[Any] = None,
        headers: Optional[dict[str, str]] = None,
        cookies: Optional[dict[str, str]] = None,
        files: Optional[dict[str, str]] = None,
        auth: Optional[Tuple[str, str]] = None,
        timeout: Optional[Union[float, Tuple[Optional[float], Optional[float]]]] = None,
        allow_redirects: Optional[bool] = None,
        proxies: Optional[dict[str, str]] = None,
        stream: Optional[bool] = None,
        verify: Optional[bool] = None,
        cert: Optional[Union[str, Tuple[str, str]]] = None,
    ) -> Response: ...

# Utility functions — IP/CIDR
def is_ipv4_address(string_ip: str) -> bool: ...
def is_valid_cidr(string_network: str) -> bool: ...
def dotted_netmask(mask: int) -> str: ...
def address_in_network(ip: str, net: str) -> bool: ...

# Utility functions — URL
def get_auth_from_url(url: str) -> Tuple[str, str]: ...
def unquote_unreserved(uri: str) -> str: ...
def requote_uri(uri: str) -> str: ...
def urldefragauth(url: str) -> str: ...
def prepend_scheme_if_needed(url: str, new_scheme: str) -> str: ...
def unicode_is_ascii(s: str) -> bool: ...

# Utility functions — Headers
def parse_header_links(value: str) -> list[dict[str, str]]: ...
def get_encoding_from_headers(headers: Any) -> Optional[str]: ...
def _parse_content_type_header(header: str) -> Tuple[str, dict[str, str]]: ...
def check_header_validity(
    header: Tuple[Union[str, bytes], Union[str, bytes]],
) -> None: ...
def parse_list_header(value: str) -> list[str]: ...
def parse_dict_header(value: str) -> dict[str, Optional[str]]: ...
def unquote_header_value(value: str, is_filename: bool = False) -> str: ...
def to_native_string(string: Union[str, bytes], encoding: str = "ascii") -> str: ...

# Utility functions — Encoding
def guess_json_utf(data: bytes) -> Optional[str]: ...

# Utility functions — Proxy
def select_proxy(
    url: str, proxies: Optional[dict[str, str]] = None
) -> Optional[str]: ...
